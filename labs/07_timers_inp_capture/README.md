## Задание 07 "timers_inp_capture"

Режим захвата по входу — это особый режим работы таймера, суть которого в следующем. При изменении логического уровня на определенном выводе микроконтроллера значение счетного регистра записывается в другой регистр, именуемый регистром захвата `TIMx_CCRx`. С помощью этого режима можно, например, **измерить длительность импульса или период сигнала**.

Планируется следующая работа. Вы подключите кнопку к микроконтроллеру, при нажатии на неё светодиод будет переключаться. Использование таймера в этом задании позволит побороться с дребезгом при помощи специального фильтра.

Для новых целей функция `timers_config` будет выглядеть иначе. Во-первых видно, что здесь настраивается пин `А5` в режиме Alternate с функцией AF2. И подтяжка к питанию. Чтобы понять почему используется именно `А5`, загляните в описание серии [stm32f051_family.pdf](https://github.com/edosedgar/stm32f0_ARM/blob/master/docs/stm32f051_family.pdf), стр. 37-38. Там расположена таблица, в которой прописаны все функции всех пинов.

<p align="center">
  <img width="700" src="https://raw.githubusercontent.com/wiki/edosedgar/stm32f0_ARM/table.png" alt="table.png"/>

</p>

А5 является первым каналом `CH1` для `TIM2`, тем самым “определенным выводом микроконтроллера”, о котором упоминалось ранее. Всего у `TIM2` присутствует 4 таких канала. Каждому каналу можно дать свою задачу. А для `CH1` в проекте задаётся режим `input capture (IC)`.

Настраивается в режиме `IC` фильтр каналу `CH1` таймера `TIM2`.

```C
LL_TIM_IC_SetFilter(TIM2, LL_TIM_CHANNEL_CH1, LL_TIM_IC_FILTER_FDIV16_N5);
```
С помощью этого фильтра отсекаются помехи на входе канала. F<sub>sampling</sub> – это частота, с которой берутся выборки входного сигнала; `N` – это количество выборок, в течении которых входной сигнал должен быть стабилен, чтобы зафиксировать изменение. В данном случае берутся 5 отсчетов, каждый через ⅓ мкс (каждый 16 такт от 48МГц). Первый раз когда все 5 отсчетов станут `0` - событие происходит.

Пин `А5` подтянут вверх, кнопка прижимает его к земле. Событие будет происходить по нажатию. Возникновение события настраивается на спад (отрицательный фронт). Polarity = Falling.

```C
LL_TIM_IC_SetPolarity(TIM2, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_FALLING);

```

Приниматься сигнал будет именно от пина `А5`, напрямую подсоединённого к `CH1` (это его `direct TI`). Поэтому именно он будет активным входом.

```C
LL_TIM_IC_SetActiveInput(TIM2, LL_TIM_CHANNEL_CH1, LL_TIM_ACTIVEINPUT_DIRECTTI);
```

Имеется возможность настроить возникновение события не по каждому фротну/спаду, а по каждому второму или четвёртому. Но в этом случае, сейчас требуется реакция на каждое нажатие. Поэтому оставляется предделитель в `DIV1`.

```C
LL_TIM_IC_SetPrescaler(TIM2, LL_TIM_CHANNEL_CH1, LL_TIM_ICPSC_DIV1);
```

После настройки канала включите его, записав соответствующий бит в Capture&Compare Enable Register `TIMx_CCER`.

```C
LL_TIM_CC_EnableChannel(TIM2, LL_TIM_CHANNEL_CH1);
```

И снова нужно включить прерывание. Обратите внимание, что тут прерывание возникает именно по событию на канале 1 `CC1`, а не по обновлению таймера `UPDATE`, как в прошлом проекте.

```C
LL_TIM_EnableIT_CC1(TIM2);
```

Под конец разрешите обработку прерываний от `TIM2`:

```C
NVIC_EnableIRQ(TIM2_IRQn);
```

А вот эта строчка выглядит так же, как и в прошлом проекте. То есть **на все события** из одного таймера есть только **одно прерывание**. Если событий, по которым оно могло произойти, много, то нужно выяснить какое по взведенным таймером флагам. В данной программе есть только одно событие, поэтому в обработчике `TIM2_IRQHandler` и **очищается соответствующий флаг**.

```C
LL_TIM_ClearFlag_CC1(TIM2);
```

Для проверки работы программы осталось только подключить кнопку к `A5`. Синяя кнопка на плате подключена к `A0`, потому предлагается взять новую кнопку.

У кнопки из ваших наборов есть 4 ножки, они уже соединены по парам. Ножки в одной плоскости соединены друг с другом (обозначено красным на картинке):

<p align="center">
  <img width="400" src="https://raw.githubusercontent.com/wiki/edosedgar/stm32f0_ARM/button.png" alt="button.PNG"/>

</p>

При нажатии на кнопку одна пара замыкается с другой парой. Тогда, первый контакт кнопки соедините с землей, а второй подключите к `А5`.

Сейчас можно сказать, что мы “выстрелили пушкой по воробьям”: мощный функционал применили для управления светодиодом. В качестве самостоятельного задания предлагается сделать нечто более прикладное, вроде измерения длительности импульса.

## Самостоятельные задания

На основе проекта `07_timers_inp_capture` сперва можно сделать простую вещь — **измерять разницу во времени между двумя нажатиями**. И выводить значение в секундах на экран. С точностью до десятых или сотых.

На данный момент работа идет с 32-битным таймером `TIM2`. Даже с частотой работы 1000 раз в секунду он не переполнится ближайшие три года. Однако в случае перехода на 16-битный таймер, быть может, придется увеличить значение предделителя, чтобы счетчик не переполнялся слишком быстро. Деление входной частоты стоит выбирать исходя из требований конкретной задачи.

Прочитать счетчик таймера можно командой `LL_TIM_GetCounter`. Но есть и более верный способ. В режиме захвата по входу (на `CH1`) значение таймера специально откладывается в регистр Capture&Compare Register канала 1 `TIMx_CCR1` ровно в момент события. Поэтому лучше будет читать актуальное значение оттуда при помощи функции `LL_TIM_IC_GetCaptureCH1`.

Предполагается завести переменную типа uint32_t с прошлым прочитанным значением. По каждому прерыванию считается разницу, записывается в переменную для вывода на индикатор, обновляется переменную с прошлым прочитанным значением.

Отталкиваясь от этого, можно осуществить **измерение длительности нажатия**. Для этого необходимы прерывания и по фронту и по спаду -  `LL_TIM_IC_POLARITY_BOTHEDGE`. Определить произошел фронт или спад в обработчике прерывания можно посмотрев значение пина `А5` при помощи функции `LL_GPIO_IsInputPinSet`. Обновляется значение на индикаторе будет сразу после отжатия кнопки, то есть после положительного фронта.

## Проектное задание

К настоящему моменту ожидается, что участники курса уже знакомы со многими полезными функциями микроконтроллера. Настоящих знаний должно быть достаточно для выполнения предложенного проектного задания. Результат работы  продемонстрирует ваш уровень знаний, креативность и подход к решению.

## Интерактивные часы-будильник

Ваша задача сделать часы, которыми можно пользоваться. Прежде всего, время должно отображаться на циферблате на семисегментном индикаторе. Во-вторых, должна иметься возможность завести или отключить будильник. Временно в качестве сигнала для будильника можно использовать светодиод. В следующих заданиях будет рассказано как заставить схему звучать. В-третьих, как и на реальных часах, естественна возможность редактировать текущее время.

Детали важны. Чем проще обращаться с будильником, тем лучше. Нет ограничений на дополнительные кнопки, энкодеры и так далее. Взаимодействие с устройством на ваш вкус.

Важно отсутствие ошибок. Крайне нежелательно, если часы останавливают ход во время выставления будильника. Или наличие возможности поставить будильник на 24:15. И тому подобное.
