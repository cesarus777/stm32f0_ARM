## Задание 08 "timers_enc"
### Работа таймера в режиме энкодера
У некоторых таймеров имеется возможность работать с энкодером. Для этого есть специальный режим таймера **encoder mode**.
Сигнал принимается с двух каналов `CH1` и `CH2` сразу, и в зависимости от вращения счётчик таймера уменьшается или увеличивается.
То есть, в отличие от лабораторной работы с внешними прерываниями, теперь счёт ведётся не в некоторой переменной,
а в конкретном счётчике `TIM2_CNT`. 
Чтобы понять как это работает, взгляните в **табличку из reference manual**. Сейчас интерес представляет **последняя строчка**. 

<p align="center">
  <img width="700" src="https://github.com/Levitsky-Ilya/stm32f0_ARM/blob/master/docs/images/table.jpg" alt="table.jpg"/>

</p>

Таймер считает вверх или вниз во-первых в зависимости от фронта или спада каналов (которые `TI1` и `TI2`), а во-вторых от прошлого состояния каналов. График зависимости сигналов на входе и счётчика от времени поясняет логику таблицы.

<p align="center">
  <img width="700" src="https://github.com/Levitsky-Ilya/stm32f0_ARM/blob/master/docs/images/graph.jpg" alt="graph.jpg"/>

</p>

Из таблицы видно, что можно заставить таймер реагировать не только на фронты обоих каналов, но и фронты лишь одного канала. Например, cчётчик будет изменяться только после перепада на `TI1`. Такой режим может быть нужен, когда один из каналов часто останавливается в промежуточном положении и возникает jitter. Или можно выставить ненулевое значение предделителя тактирующей частоты. При любом из подходов борьбы с таким дребезгом таймер будет отсчитывать меньше за один оборот энкодера.

### Настройка таймера в режиме энкодера
Перейдём непосредственно к лабраторной работе. В `08_timers_enc` предлагается зажигать синий светодиод при счёте вверх, и зелёный при счёте вниз. Чтобы не создавать иллюзию, что необходимо организовать работу ещё какой-то другой периферии, все прочие таймеры и прерывания опущены. 

Работа с таймером начинается с настройки его каналов; их необходимо два: `CH1` и `CH2`. Им соответствуют пины `А5` и `А1`. Как и в прошлой работе, для обоих пинов включён альтернативный режим, функция `LL_GPIO_AF_2`, подтяжка вверх.

```C
// Обязательное тактирирование порта А
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);

// Настройка пинов А5 и А1 в качестве каналов CH1 и CH2 таймера TIM2
LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_1, LL_GPIO_MODE_ALTERNATE);
LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_ALTERNATE);
LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_1, LL_GPIO_AF_2);
LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_5, LL_GPIO_AF_2);

// Подтяжка к питанию
LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_1, LL_GPIO_PULL_UP);
LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_5, LL_GPIO_PULL_UP);
```

Для таймера следует включить режим энкодера. Так как хотелось бы реагировать на каждый фронт обоих каналов, как описано на третьей строчке таблицы, то это указывается аргументом:

```C
// Тактирование таймера TIM2
LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);

// Режим энкодера -         реакция по всем фронтам обоих каналов
LL_TIM_SetEncoderMode(TIM2, LL_TIM_ENCODERMODE_X4_TI12);
```

Следующим шагом для обоих каналов выставляется реакция только по отрицательному фронту (falling). Дело в том, что разработчики не предусмотрели режим работы в точности как нарисовано на временной диаграмме. Если попытаться включить реакцию на оба типа фронтов (both edges), то счётчик будет хаотично переключаться, о чем нас предупреждают в [справочном руководстве](https://github.com/edosedgar/stm32f0_ARM/blob/master/docs/stm32f0xx_rm.pdf). Поэтому есть возможность задать только один из двух возможных вариантов: rising или falling edge. Здесь выбран второй вариант по аналогии с прошлой работой с энкодером.

```C
LL_TIM_IC_SetPolarity(TIM2, LL_TIM_CHANNEL_CH1,
                          LL_TIM_IC_POLARITY_FALLING);
LL_TIM_IC_SetPolarity(TIM2, LL_TIM_CHANNEL_CH2,
                          LL_TIM_IC_POLARITY_FALLING);
```

В самом конце выставляется верхняя граница счёта таймера, и затем сам таймер включается. 

```C
// Таймер считает          до этого значения
LL_TIM_SetAutoReload(TIM2, 0xFFFF);
// Включение таймера
LL_TIM_EnableCounter(TIM2);
```

В функции `main` опрашивается направление счёта таймера через фиксированный интервал времени. На основе направления счёта зажигается синий или зелёный светодиод.

## Самостоятельные задания

Подключите каналы энкодера к пинам `А5` и `А1`. Если сами пины были подтянуты к питанию, то среднюю ножку энкодера следует подключить к земле. Пронаблюдйте так светодиоды реагируют на вращение энкодера.

Стандартное задание - вывести значение таймера на индикатор. Оцените, насколько быстро растёт счётчик при одном повороте. 
